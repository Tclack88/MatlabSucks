# -*- coding: utf-8 -*-
"""sma_help.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YvLLs_-dZgXbF1Ho2_gnkrQjP4DV3Pw6

## Eigenvalues and stuff
"""

# This was just a quick help for my exam, probably too much of a mish mash to
# be useful. Originally an ipynb, it doesn't make much sense to run from a
# terminal

import numpy as np
from numpy.linalg import eig, inv, pinv, multi_dot
from numpy import matmul, array

M = array([[5,0],[0,1]])
print(inv(M))
K = array([[12,-2],[-2,2]])
MiK = matmul(inv(M),K)
print(MiK)
# A = array([[0,1],[-6,-5]])
# A = array([[2,-1],[-1.5,1.5]])
# A = array([[-28,8],[8,-16]])


eigen = eig(MiK)
# V = eig
eigen

np.sqrt(eigen[0][1])

V = array([eigen[1][0],eigen[1][1]])
Vi = inv(V)

np.exp(A)

multi_dot((V,np.exp(A),Vi))

inv(array([[1,1],[-2,-3]]))

ar = array([[1,0,0],[0,2,0],[0,0,3]])
inv(ar)

"""## Inverse laplace and sympy"""

import sympy as sym
from math import sqrt
s,t  = sym.symbols("s,t")

G = 1/((s+2)*(s+3))
G2 = G.apart()
G2
# sym.inverse_laplace_transform(G2,s,t)
# sym.solve(z**2+.2*z-.5, rational=True)


# G = (s+5)/((s+.1)*(s**2+6*s+10))
# U = sym.laplace_transform(4*sym.sin(50*t),t,s)[0]

# Y = G*U
# Y
# # res = sym.inverse_laplace_transform(Y,s,t)
# res = sym.inverse_laplace_transform(sym.simplify(sym.apart(Y)),s,t)
# res

sym.inverse_laplace_transform(G2,s,t)

a = U.evalf(subs={z:-1/10 + sym.sqrt(51)/10})
U1 = z-(-1/10 - sqrt(51)/10)
b = U1.evalf(subs={z:-1/10 + sqrt(51)/10})
print(a/b)

a = U.evalf(subs={z:-1/10 - sym.sqrt(51)/10})
U2 = z-(-1/10 + sqrt(51)/10)
b = U2.evalf(subs={z:-1/10 - sqrt(51)/10})
print(a/b)

print(Y)

sym.apart(Y)

D = sym.apart(sym.simplify(sym.apart(Y),rational=True))

sym.inverse_laplace_transform(D ,s,t)

# import mpmath as mp
# import numpy as np


# def f(s):
#   return 200*(s + 5)/((s + 0.1)*(s**2 + 2500)*(s**2 + 6*s + 10))

# t_range = np.linspace(.01,500,1000)
# G = map( lambda x: mp.invertlaplace(f, x, method = 'talbot', dps = 10, degree = 18), t_range )
# glist = list(G)
# c = np.array(glist, dtype=float)
# import matplotlib.pyplot as plt

# plt.plot(t_range,c)



# Z transform:


def z_transform(expr,n_symbol, start=0, stop=100):
    '''Uses the z transform defination to get its summation, use ".doit()" on the return value
    to evaluate the summation
    '''
    z = sym.symbols('z')
    return sym.Sum(expr.replace(n_symbol, n)*z**(-n),(n,start,stop))

n = sym.symbols('n')
z_transf = z_transform(20/(n*(n+9)), n ,0, 100).doit()
z_transf

sym.solve(s**2+.2*s-.5)

K = sym.simplify(sym.apart(Y))
res = sym.inverse_laplace_transform(K,s,t)
res

Y.evalf(subs={'s':0})

import numpy as np
import matplotlib.pyplot as plt
t_range = np.linspace(0,10,100)
y_range= -np.cos(7.07*t_range)
plt.plot(t_range,y_range)

def invL(F):
    return sym.inverse_laplace_transform(F, s, x)
  
inv = invL(Y*U)
sym.simplify(inv,rational=True)

inv

print(5.64705882352941*.115990990990991)
5.64705882352941*.195945945945946

invL(sym.simplify(g, rational=True))

H = (4-s)/(s**2+5*s+6)
k,K1,K2,Y,U = sym.symbols("k,K1,K2,Y,U")

sym.solve([K1-U+K2,
           K1*H-Y,
           10*Y-k*Y-K2])



"""## underdamped calculations"""

import sympy as sym
# GET damping coefficiient (z) from graphically estimating rise time
z,pi,M = sym.symbols('z,pi,M')
Func = sym.exp(-z*pi/sym.sqrt(1-z**2)) - M
z_solved = sym.solve(Func,z)
a = z_solved[0].evalf(subs={M:.6,pi:3.14159})
a

z_solved

z_solved[0]

"""## Bode Plots"""

!pip install control

import numpy as np
import matplotlib.pyplot as plt
import control

import warnings
warnings.filterwarnings('ignore')

G = 0.2*control.tf([0.5,1],[1.5,0.5,1])
print(G)
mag,phase,omega = control.bode(G)

"""### Bode plot for Matrix of values"""

# from X' = AX + B U
# Y = CX  + 0D
# A is matrix of matrices 4x4 overall with A = ...
#     0        I
#    -M^(-1)    K
# and in this example an input of x1 causes only motion in x2, thus input B matrix is 0 0 1 0 (1 for x1_dot) and C matrix is 0 1 0 0 (1 for x2)
A = "0 0 1 0; 0 0 0 1;-2 1 0 0; .5 -1.5 0 0"
B = "0;0;1;0"
C = "0 1 0 0"
D = "0"
#sys = control.ss("1. -2; 3. -4", "5.; 7", "6. 8", "9.")
sys = control.ss(A,B,C,D)

mag, phase, omega = control.bode(sys)



"""## anything else"""

import sympy as sym
x = sym.symbols('x')
Func = x**2+3*x + -28
sym.solve(Func)

a,b,c,d =.5,-.2,-.5,.6
func = x*(c+d*x)/((1+2*b*x)*(1+a*x))

sym.apart(func)

a,b,c,d =.5,-.2,-.5,.6
func = x*(c+d*x)/((1+2*b*x)*(1+a*x))
sym.solve(func)

a,b,c,d =.8,-.6,-.5,.6
func = x*(c+d*x)/((1+2*b*x)*(1+a*x))
sym.solve(func)

a,b,c,d =.9,-.4,1,-.6
func = x*(c+d*x)/((1+2*b*x)*(1+a*x))
sym.solve(func)

a,b,c,d =5,-.3,1,-.6
func = x*(c+d*x)/((1+2*b*x)*(1+a*x))
sym.solve(func)

#####
import sympy as sym
s = sym.symbols('s')
f1 = -10/(s**2-3*s+6)
f2 = -3/(s**2-7*s+5)

sym.simplify(f1+f2)

f3 = 1/(s**2+2*s+1)
f3.apart()

#### q12
f4 = 3/(s*(7*s**2+3*s+2))
print(f4.apart())

sym.inverse_laplace_transform(-3*(7*s + 3)/(2*(7*s**2 + 3*s + 2)),s,x)

